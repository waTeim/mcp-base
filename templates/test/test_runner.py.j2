#!/usr/bin/env python3
"""
{{ server_name }} MCP Server Test Runner

Primary testing tool with two modes:
1. Automated tests via plugin system (default)
2. Interactive Inspector UI (--use-inspector flag)

Automatically obtains tokens from auth0-config.json if available.

Development Mode (No-Auth):
  For rapid development and testing without authentication:
    ./test-mcp.py --url http://localhost:{{ port + 1 }}/test --no-auth

  Requires the test server to be started in no-auth mode:
    python {{ server_name_snake }}_test_server.py --no-auth --port {{ port + 1 }}
"""

import os
import sys
import json
import argparse
import subprocess
import shutil
import time
import asyncio
import importlib
import inspect
from pathlib import Path
from typing import Optional, Dict, Any, List


class Colors:
    """Colors for terminal output."""
    RED = '\033[0;31m'
    GREEN = '\033[0;32m'
    YELLOW = '\033[1;33m'
    BLUE = '\033[0;34m'
    NC = '\033[0m'  # No Color

    @staticmethod
    def red(text): return f"{Colors.RED}{text}{Colors.NC}"
    @staticmethod
    def green(text): return f"{Colors.GREEN}{text}{Colors.NC}"
    @staticmethod
    def yellow(text): return f"{Colors.YELLOW}{text}{Colors.NC}"
    @staticmethod
    def blue(text): return f"{Colors.BLUE}{text}{Colors.NC}"


def get_user_token_interactive() -> Optional[str]:
    """
    Get user token by running get-user-token.py script.

    Returns:
        Access token or None if failed
    """
    print()
    print("=" * 70)
    print(Colors.blue("üîê USER AUTHENTICATION REQUIRED"))
    print("=" * 70)
    print()
    print("The MCP server requires the 'openid' scope, which needs user login.")
    print("Running get-user-token.py to authenticate...")
    print()

    script_path = Path(__file__).parent / "get-user-token.py"

    try:
        result = subprocess.run(
            [sys.executable, str(script_path)],
            capture_output=False,
            text=True
        )

        if result.returncode != 0:
            print()
            print(Colors.red("‚ùå User authentication failed"))
            return None

        token_file = Path("/tmp/user-token.txt")
        if token_file.exists():
            token = token_file.read_text().strip()
            print()
            print(Colors.green("‚úÖ User token obtained successfully"))
            return token
        else:
            print()
            print(Colors.red("‚ùå Token file not found after authentication"))
            return None

    except Exception as e:
        print(Colors.red(f"‚ùå Error running get-user-token.py: {e}"))
        return None


def check_npx() -> bool:
    """Check if npx is available."""
    return shutil.which("npx") is not None


def load_auth0_config(config_path: str = "auth0-config.json") -> Optional[Dict[str, Any]]:
    """Load Auth0 configuration from file."""
    config_file = Path(config_path)
    if not config_file.exists():
        return None

    try:
        with open(config_file, 'r') as f:
            return json.load(f)
    except Exception as e:
        print(Colors.yellow(f"Warning: Failed to load {config_path}: {e}"))
        return None


def get_token_from_auth0(config: Dict[str, Any]) -> Optional[str]:
    """
    Get an access token using user authentication (Authorization Code + PKCE).

    Args:
        config: Auth0 configuration dictionary

    Returns:
        Access token or None if failed
    """
    print(Colors.blue("Using user authentication (same as Claude Desktop)"))
    print()
    return get_user_token_interactive()


def topological_sort_plugins(plugins: List) -> List:
    """
    Sort plugins based on dependencies using topological sort.

    Args:
        plugins: List of plugin instances

    Returns:
        Sorted list of plugins (dependencies first)
    """
    plugin_map = {p.get_name(): p for p in plugins}
    visited = set()
    result = []

    def visit(plugin):
        if plugin.get_name() in visited:
            return
        visited.add(plugin.get_name())
        all_deps = list(set(plugin.depends_on + plugin.run_after))
        for dep_name in all_deps:
            if dep_name in plugin_map:
                visit(plugin_map[dep_name])
        result.append(plugin)

    for plugin in plugins:
        visit(plugin)

    return result


def discover_plugins(plugins_dir: Path) -> List:
    """Discover all test plugins in the plugins directory."""
    plugins = []

    if not plugins_dir.exists():
        return plugins

    sys.path.insert(0, str(plugins_dir.parent))

    for plugin_file in plugins_dir.glob("test_*.py"):
        try:
            module_name = f"plugins.{plugin_file.stem}"
            module = importlib.import_module(module_name)

            for name, obj in inspect.getmembers(module, inspect.isclass):
                if (hasattr(obj, 'test') and
                    callable(obj.test) and
                    obj.__module__ == module_name):
                    plugins.append(obj())

        except Exception as e:
            print(Colors.yellow(f"‚ö†Ô∏è  Failed to load plugin {plugin_file.name}: {e}"))

    plugins = topological_sort_plugins(plugins)
    return plugins


async def run_automated_tests(transport: str, url: str = None, token: str = None,
                              token_file: str = None, auth0_config_path: str = "auth0-config.json",
                              output_file: str = None, output_format: str = "json",
                              no_auth: bool = False, debug_log: str = None) -> int:
    """
    Run automated tests using plugin system.

    Args:
        transport: 'http' (stdio not supported for remote MCP)
        url: HTTP URL for MCP server
        token: JWT bearer token for HTTP authentication
        token_file: Path to file containing JWT token
        auth0_config_path: Path to auth0-config.json for automatic token retrieval
        output_file: Path to save test results (optional)
        output_format: Format for saved results ('json' or 'junit')
        no_auth: Skip authentication (for no-auth server mode)
        debug_log: Path to save detailed request/response log

    Returns:
        Exit code (0 for success, 1 for failure)
    """
    print("=" * 70)
    print(Colors.blue("{{ server_name }} MCP Server - Automated Test Suite"))
    print("=" * 70)
    print()

    plugins_dir = Path(__file__).parent / "plugins"
    plugins = discover_plugins(plugins_dir)

    if not plugins:
        print(Colors.yellow("‚ö†Ô∏è  No test plugins found"))
        print(f"   Expected plugins in: {plugins_dir}")
        print()
        print("To create a test plugin, add a file like test/plugins/test_my_tool.py:")
        print("  from plugins import TestPlugin, TestResult")
        print("  class MyToolTest(TestPlugin):")
        print("      tool_name = 'my_tool'")
        print("      async def test(self, session): ...")
        return 1

    print(f"üìã Discovered {len(plugins)} test plugin(s)")
    for plugin in plugins:
        print(f"   ‚Ä¢ {plugin.tool_name}: {plugin.description}")
    print()

    # HTTP transport only
    print(Colors.blue("Transport: HTTP"))
    print(f"URL: {url}")
    print()

    auth_token = None
    token_source = None

    if no_auth:
        print(Colors.yellow("‚ö†Ô∏è  Running without authentication (--no-auth)"))
        print()
    elif token:
        auth_token = token.strip()
        token_source = "command line argument"
    elif token_file:
        token_path = Path(token_file)
        if not token_path.exists():
            print(Colors.red(f"‚ùå Token file not found: {token_file}"))
            return 1
        auth_token = token_path.read_text().strip()
        if not auth_token:
            print(Colors.red(f"‚ùå Token file is empty: {token_file}"))
            return 1
        token_source = f"file: {token_file}"
    else:
        auth0_config = load_auth0_config(auth0_config_path)
        if auth0_config:
            print(Colors.green(f"‚úÖ Found {auth0_config_path}"))
            print()
            auth_token = get_token_from_auth0(auth0_config)
            if auth_token:
                token_source = "user authentication (Authorization Code Flow)"
            else:
                print()
                print(Colors.red("‚ùå Failed to obtain authentication token"))
                return 1
        else:
            print(Colors.yellow(f"‚ö†Ô∏è  No {auth0_config_path} found"))
            print("   Attempting connection without authentication...")
            print()

    if auth_token:
        print(Colors.green(f"‚úÖ Using token from: {token_source}"))
        print()

    try:
        from mcp.client.streamable_http import streamablehttp_client
        from mcp.client.session import ClientSession

        # Construct MCP endpoint URL
        if auth_token and not url.endswith(('/mcp', '/mcp/', '/test', '/test/')):
            mcp_url = f"{url}/test/"
            print(Colors.blue("Using /test/ endpoint (Auth0 token with standard OIDC)"))
        else:
            mcp_url = f"{url}/mcp" if not url.endswith(('/mcp', '/mcp/', '/test', '/test/')) else url

        headers = {}
        if auth_token:
            headers["Authorization"] = f"Bearer {auth_token}"

        print(Colors.blue(f"Connecting to: {mcp_url}"))
        print()

        async with streamablehttp_client(mcp_url, headers=headers) as (read, write, get_session_id):
            async with ClientSession(read, write) as session:
                init_result = await session.initialize()
                print(Colors.green(f"‚úÖ Connected to server"))
                print(f"   Name: {init_result.serverInfo.name}")
                print(f"   Version: {init_result.serverInfo.version}")
                print()

                exit_code, results = await run_plugin_tests(session, plugins)

                if output_file:
                    save_test_results(results, output_file, output_format, transport, url)

                return exit_code

    except ImportError as e:
        print(Colors.red(f"‚ùå Failed to import MCP Streamable HTTP client library: {e}"))
        print()
        print("Install with: pip install mcp")
        return 1
    except Exception as e:
        print(Colors.red(f"‚ùå Failed to connect to server: {e}"))
        import traceback
        traceback.print_exc()
        return 1


async def run_plugin_tests(session, plugins: List) -> tuple[int, List]:
    """
    Run all plugin tests and report results.

    Returns:
        Tuple of (exit_code, results_list)
    """
    print("=" * 70)
    print("Running Tests")
    print("=" * 70)
    print()

    results = []
    passed = 0
    failed = 0
    failed_tests = set()

    for plugin in plugins:
        plugin_name = plugin.get_name()

        deps_failed = [dep for dep in plugin.depends_on if dep in failed_tests]
        if deps_failed:
            print(f"‚è≠Ô∏è  {plugin_name}... ", end="")
            print(Colors.yellow(f"SKIPPED (dependency failed: {', '.join(deps_failed)})"))
            print()
            from plugins import TestResult
            results.append(TestResult(
                plugin_name=plugin_name,
                tool_name=plugin.tool_name,
                passed=False,
                message=f"Skipped because dependency failed: {', '.join(deps_failed)}"
            ))
            failed += 1
            failed_tests.add(plugin_name)
            continue

        print(f"‚ñ∂Ô∏è  {plugin_name}...", end=" ", flush=True)

        try:
            result = await plugin.test(session)
            results.append(result)

            if result.passed:
                print(Colors.green("‚úÖ PASS"))
                passed += 1
            else:
                print(Colors.red("‚ùå FAIL"))
                failed += 1
                failed_tests.add(plugin_name)

            if result.duration_ms:
                print(f"   Duration: {result.duration_ms:.1f}ms")
            print(f"   {result.message}")
            if result.error:
                print(Colors.red(f"   Error: {result.error}"))
            print()

        except Exception as e:
            print(Colors.red("‚ùå EXCEPTION"))
            print(Colors.red(f"   Unexpected error: {e}"))
            print()
            failed += 1
            failed_tests.add(plugin_name)

            from plugins import TestResult
            results.append(TestResult(
                plugin_name=plugin_name,
                tool_name=plugin.tool_name,
                passed=False,
                message=f"Unexpected exception during test",
                error=str(e)
            ))

    print("=" * 70)
    print("Test Summary")
    print("=" * 70)
    print()
    print(f"Total:  {passed + failed} tests")
    print(Colors.green(f"Passed: {passed}"))
    print(Colors.red(f"Failed: {failed}"))
    print()

    if failed == 0:
        print(Colors.green("üéâ All tests passed!"))
        exit_code = 0
    else:
        print(Colors.red(f"‚ùå {failed} test(s) failed"))
        exit_code = 1

    return exit_code, results


def save_test_results(results: List, output_file: str, format: str = "json",
                      transport: str = "http", url: str = None):
    """Save test results to a file."""
    from datetime import datetime, timezone

    if format == "json":
        output = {
            "timestamp": datetime.now(timezone.utc).isoformat().replace('+00:00', 'Z'),
            "transport": transport,
            "url": url,
            "summary": {
                "total": len(results),
                "passed": sum(1 for r in results if r.passed),
                "failed": sum(1 for r in results if not r.passed),
                "duration_ms": sum(r.duration_ms or 0 for r in results)
            },
            "tests": [
                {
                    "plugin_name": r.plugin_name,
                    "tool_name": r.tool_name,
                    "passed": r.passed,
                    "message": r.message,
                    "error": r.error,
                    "duration_ms": r.duration_ms
                }
                for r in results
            ]
        }

        with open(output_file, 'w') as f:
            json.dump(output, f, indent=2)

        print()
        print(Colors.green(f"‚úÖ Test results saved to: {output_file}"))
        print(f"   Format: JSON")

    elif format == "junit":
        import xml.etree.ElementTree as ET

        total = len(results)
        failures = sum(1 for r in results if not r.passed)
        duration_s = sum(r.duration_ms or 0 for r in results) / 1000.0

        testsuite = ET.Element("testsuite", {
            "name": "{{ server_name }} MCP Automated Tests",
            "tests": str(total),
            "failures": str(failures),
            "errors": "0",
            "time": f"{duration_s:.3f}",
            "timestamp": datetime.now(timezone.utc).isoformat().replace('+00:00', 'Z')
        })

        properties = ET.SubElement(testsuite, "properties")
        ET.SubElement(properties, "property", {"name": "transport", "value": transport})
        if url:
            ET.SubElement(properties, "property", {"name": "url", "value": url})

        for r in results:
            testcase = ET.SubElement(testsuite, "testcase", {
                "name": r.plugin_name,
                "classname": f"mcp.tools.{r.tool_name}",
                "time": f"{(r.duration_ms or 0) / 1000:.3f}"
            })

            if not r.passed:
                failure = ET.SubElement(testcase, "failure", {
                    "message": r.message
                })
                if r.error:
                    failure.text = r.error

        tree = ET.ElementTree(testsuite)
        ET.indent(tree, space="  ")
        tree.write(output_file, encoding="utf-8", xml_declaration=True)

        print()
        print(Colors.green(f"‚úÖ Test results saved to: {output_file}"))
        print(f"   Format: JUnit XML")


def main():
    parser = argparse.ArgumentParser(
        description="{{ server_name }} MCP Server Test Runner",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Run automated tests with HTTP transport
  ./test-mcp.py --url https://{{ server_name_kebab }}.example.com

  # Save test results to JSON file
  ./test-mcp.py --url https://{{ server_name_kebab }}.example.com --output results.json

  # Save test results to JUnit XML (for CI/CD)
  ./test-mcp.py --url https://{{ server_name_kebab }}.example.com --output results.xml --format junit

  # Development mode (no authentication) - requires no-auth server
  ./test-mcp.py --url http://localhost:{{ port + 1 }}/test --no-auth

  # With debug logging for troubleshooting
  ./test-mcp.py --url http://localhost:{{ port + 1 }}/test --no-auth --debug-log /tmp/mcp-debug.log

  # Launch Inspector UI for manual testing
  ./test-mcp.py --use-inspector --url https://{{ server_name_kebab }}.example.com --use-proxy

  # Inspector with kubectl port-forward
  ./test-mcp.py --use-inspector --port-forward --namespace {{ default_namespace }}

Testing Modes:
  Default         - Automated tests via plugin system (no Inspector)
  --use-inspector - Launch Inspector UI for manual testing
  --no-auth       - Development mode (skip authentication, use with no-auth server)

Inspector Options (only with --use-inspector):
  --use-proxy     - Auto-start auth proxy (eliminates manual header setup)
  --port-forward  - Use kubectl to access in-cluster service

Development Mode (No-Auth):
  Start the test server without authentication:
    python {{ server_name_snake }}_test_server.py --no-auth --port {{ port + 1 }}

  Then run tests without authentication:
    ./test-mcp.py --url http://localhost:{{ port + 1 }}/test --no-auth

Environment Variables:
  MCP_HTTP_URL    Default HTTP URL (default: http://localhost:{{ port }})

Notes:
  - Automated tests use plugin system (test/plugins/test_*.py)
  - Automatically obtains user token when needed
"""
    )

    parser.add_argument(
        '-u', '--url',
        default=os.getenv('MCP_HTTP_URL', 'http://localhost:{{ port }}'),
        help='HTTP URL (default: http://localhost:{{ port }} or $MCP_HTTP_URL)'
    )
    parser.add_argument(
        '--token',
        help='JWT bearer token for HTTP mode'
    )
    parser.add_argument(
        '--token-file',
        help='File containing JWT bearer token'
    )
    parser.add_argument(
        '--auth0-config',
        default='auth0-config.json',
        help='Path to auth0-config.json (default: ./auth0-config.json)'
    )
    parser.add_argument(
        '--use-inspector',
        action='store_true',
        help='Launch Inspector UI for manual testing (default: run automated tests)'
    )
    parser.add_argument(
        '--use-proxy',
        action='store_true',
        help='[Inspector only] Start local auth proxy automatically'
    )
    parser.add_argument(
        '--proxy-port',
        type=int,
        default=8889,
        help='Auth proxy port (default: 8889)'
    )
    parser.add_argument(
        '--port-forward',
        action='store_true',
        help='Use kubectl port-forward to access MCP server in cluster'
    )
    parser.add_argument(
        '--namespace',
        default='{{ default_namespace }}',
        help='Kubernetes namespace for port-forward (default: {{ default_namespace }})'
    )
    parser.add_argument(
        '--service',
        default='{{ chart_name }}-{{ chart_name }}',
        help='Kubernetes service name for port-forward'
    )
    parser.add_argument(
        '-o', '--output',
        dest='output_file',
        help='Save test results to file (automated tests only)'
    )
    parser.add_argument(
        '-f', '--format',
        dest='output_format',
        choices=['json', 'junit'],
        default='json',
        help='Output format for test results (default: json)'
    )
    parser.add_argument(
        '--no-auth',
        action='store_true',
        help='Skip authentication (for testing against no-auth servers)'
    )
    parser.add_argument(
        '--debug-log',
        dest='debug_log',
        help='Save detailed request/response log for debugging'
    )

    args = parser.parse_args()

    if not args.use_inspector:
        exit_code = asyncio.run(run_automated_tests(
            transport='http',
            url=args.url,
            token=args.token,
            token_file=args.token_file,
            auth0_config_path=args.auth0_config,
            output_file=args.output_file,
            output_format=args.output_format,
            no_auth=args.no_auth,
            debug_log=args.debug_log
        ))
        sys.exit(exit_code)

    # Inspector mode
    if not check_npx():
        print(Colors.red("Error: npx is not installed"))
        print("Please install Node.js and npm to use the MCP Inspector")
        sys.exit(1)

    print("=" * 50)
    print("{{ server_name }} MCP Inspector")
    print("=" * 50)
    print()

    token = None
    token_source = None

    if args.token:
        token = args.token.strip()
        token_source = "command line argument"
    elif args.token_file:
        token_file_path = Path(args.token_file)
        if not token_file_path.exists():
            print(Colors.red(f"Error: Token file not found: {args.token_file}"))
            sys.exit(1)
        token = token_file_path.read_text().strip()
        if not token:
            print(Colors.red(f"Error: Token file is empty: {args.token_file}"))
            sys.exit(1)
        token_source = f"file: {args.token_file}"
    else:
        auth0_config = load_auth0_config(args.auth0_config)
        if auth0_config:
            print(Colors.green(f"‚úÖ Found {args.auth0_config}"))
            print()
            token = get_token_from_auth0(auth0_config)
            if token:
                token_source = "user authentication (Authorization Code Flow)"
            else:
                print()
                print(Colors.red("‚ùå Failed to obtain token via user authentication"))
                if args.use_proxy:
                    sys.exit(1)
                else:
                    print()
                    print(Colors.yellow("‚ö†Ô∏è  Could not automatically obtain token"))
                    print()
        else:
            print(Colors.yellow(f"‚ö†Ô∏è  No {args.auth0_config} found"))
            print()

    print(f"{Colors.blue('Transport:')} HTTP")

    background_processes = []

    try:
        if args.port_forward:
            print(f"{Colors.blue('Mode:')} kubectl port-forward")
            print(f"{Colors.blue('Namespace:')} {args.namespace}")
            print(f"{Colors.blue('Service:')} {args.service}")
            print()

            print(Colors.green("Starting kubectl port-forward..."))
            forward_port = {{ port }}
            port_forward_cmd = [
                'kubectl', 'port-forward',
                '-n', args.namespace,
                f'svc/{args.service}',
                f'{forward_port}:{{ port }}'
            ]

            port_forward_proc = subprocess.Popen(
                port_forward_cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE
            )
            background_processes.append(('kubectl port-forward', port_forward_proc))
            time.sleep(2)

            mcp_endpoint = f"http://localhost:{forward_port}/mcp"
            print(f"‚úÖ Port-forward established")
            print()

        elif args.use_proxy:
            print(f"{Colors.blue('Mode:')} Auth proxy (auto-injects headers)")
            print(f"{Colors.blue('Backend:')} {args.url}")
            print(f"{Colors.blue('Proxy port:')} {args.proxy_port}")
            print()

            if not token:
                print(Colors.red("Error: --use-proxy requires a token"))
                sys.exit(1)

            token_file_path = Path("/tmp/mcp-user-token.txt")
            token_file_path.write_text(token)

            print(Colors.green("Starting auth proxy..."))
            proxy_cmd = [
                sys.executable,
                './test/mcp-auth-proxy.py',
                '--backend', args.url,
                '--port', str(args.proxy_port),
                '--token-file', str(token_file_path)
            ]

            proxy_proc = subprocess.Popen(proxy_cmd)
            background_processes.append(('auth proxy', proxy_proc))
            time.sleep(2)

            if proxy_proc.poll() is not None:
                print(Colors.red(f"‚úó Proxy exited with code {proxy_proc.returncode}"))
                sys.exit(1)

            mcp_endpoint = f"http://localhost:{args.proxy_port}/mcp"
            print(f"‚úÖ Auth proxy running at http://localhost:{args.proxy_port}")
            print()

        else:
            print(f"{Colors.blue('Mode:')} Direct connection")
            print(f"{Colors.blue('URL:')} {args.url}")
            print()

            if token:
                print(f"{Colors.blue('Authentication:')} JWT Bearer Token ({token_source})")
            else:
                print(f"{Colors.yellow('Authentication:')} None (development mode only!)")
            print()

            mcp_endpoint = f"{args.url}/mcp"

        print(Colors.green("Starting MCP Inspector..."))
        print(f"{Colors.blue('Connecting to:')} {mcp_endpoint}")
        print()

        cmd = [
            'npx', '@modelcontextprotocol/inspector',
            '--transport', 'http',
            '--url', mcp_endpoint
        ]

        try:
            subprocess.run(cmd, check=True)
        except subprocess.CalledProcessError as e:
            print(Colors.red(f"Error: Inspector exited with code {e.returncode}"))
            sys.exit(e.returncode)
        except KeyboardInterrupt:
            print()
            print("Interrupted by user")

    finally:
        for name, proc in background_processes:
            print()
            print(Colors.yellow(f"Stopping {name}..."))
            proc.terminate()
            try:
                proc.wait(timeout=5)
                print(f"‚úÖ {name} stopped")
            except subprocess.TimeoutExpired:
                proc.kill()
                print(f"‚ö†Ô∏è  {name} killed")


if __name__ == "__main__":
    main()
